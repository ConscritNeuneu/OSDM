---
layout: page
title: Technical Principles
hide_hero: true
permalink: /spec/technical-principles
---

## Design Guidelines

- **Do not reinvent the wheel** - Use existing concepts whenever possible (e.g. type system of OpenAPI, Problem details,...).
- Strive for a Level 3 of [REST maturity](https://martinfowler.com/articles/richardsonMaturityModel.html).
- Use [semantic versioning](https://semver.org).

## Derived Guidelines

- Whenever a resource returned in a response can contain embedded resources, the request must allow specifying whether and which embedded resources should be returned in full or as references.
- Follow [Zalando RESTful API and Event Scheme guidelines](https://opensource.zalando.com/restful-api-guidelines/)
- Use of the JSON Problem element
- Standard Patch operations (not JSON PATCH)
- A resource is either represented in full or as a reference. The reference element has the name of the resource post-fixed with "Ref". References normally only contains the URL to the referenced resource and a title element allowing to summarize the resource in one short string
- Although examples or recommendations are provided as to which information should best be represented in the title string, each implementor as the freedom to modify it to best suit his needs.
- Enumerations for very stable entities with limited set only, otherwise code lists. Stations codes are code lists.
- Where possible, existing UIC code lists should be favored.
- Creation/ modification calls return the created/modified resource (not just an ok code)

## Error Handling

In order to communicate errors to a consumer we support [RFC7807](https://tools.ietf.org/html/rfc7807).

This RFC defines a "problem detail" as a way to carry machine- readable details of errors in a HTTP response to avoid the need to define new error response formats for HTTP APIs.

A problem details object can have the following members:

- `type` - A URI reference [RFC3986](https://tools.ietf.org/html/rfc3986) that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank".
- `title` - A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231](https://tools.ietf.org/html/rfc7231), Section 3.4).
- `status` - The HTTP status code ([RFC7231](https://tools.ietf.org/html/rfc7231), Section 6) generated by the origin server for this occurrence of the problem.
- `detail` - A human-readable explanation specific to this occurrence of the problem.
- `instance` - A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.

Consumers MUST use the `type` string as the primary identifier for the problem type; the `title` string is advisory and included only for users who are not aware of the semantics of the URI and do not have the ability to discover them (e.g., offline log analysis). Consumers SHOULD NOT automatically dereference the type URI.

## Security and Authentication

These aspects are *not* part of the OSDM specification. However each implementor of OSDM should define its own mechanisms, therefore some strongly recommended issues are described.

OSDM uses RESTful requests/responses, therefore HttpStatus are declared in the API specification.

## Authentication

There are several API-Management (APIM) solutions on the market for e.g.:

- certain cloud-providers offer necessary services already (for e.g. AWS, ..)
- open source or licencable applications to install by your devOps Team (for e.g. 3Scale)
- simple mechanisms like Basic Auth as part of the Swagger/OpenAPI specification (though these might often be not good enough for serious production)

We recommend you to satisfy the following requirements:

- A registration service allows a consumer to register the necessary data (like: Organization, tech. admin, commercial admin, support line, other non-functional requirements like throtteling limits) for approvement by the team providing access.
any registered consumer will be approved or rejected
if approved a unique, technical "ClientId" results and will be passed to the consumer

- A login service allows to request a valid token (for e.g. OAauth2) by the registered ClientId and related secret
per configuration the validity duration of the token may be set (for e.g. 30min.), after that the token must be renewed by the consumer
optionally the token might be revoked (for e.g. if your devOps realizes the consumer does not behave as expected)

- A passthrough service expects the token (typically in the header, where the bearer token contains the clientId) for each request made by the consumer
  - validates the token and if ok "redirection" to the underlying system is performed (not OK results typically in any 401 or 403 faults)
the APIM should support RESTful service-contracts in relation to OSDM.
- In multi-environments (like DEV, TEST, INT, PROD) consumers might register for each environment separately
  - with different non-functional requirements
  - with different authorization for specific API (if you want to configure that at all)
- Easy testable (for e.g. Postman)

For example at SBB we use [3Scale](https://www.redhat.com/de/technologies/jboss-middleware/3scale) as APIM solution which powers the SBB official service portal  [developer.sbb.ch](https://developer.sbb.ch/).

### User Lookup

From a devOps perspective it might by hard to control who uses your API (for e.g. `ClientId` and secret might by passed around or hacked).

The following issues should be defined outside of OSDM:

- Additional legal contracts with consumer
- IP white listing
- Mapping of related user properties to the technical `ClientId`
